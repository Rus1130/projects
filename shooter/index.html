<style>
    :root{
        cursor: crosshair;
    }
    .debug {
        z-index: 100;
        position: absolute;
        user-select: none;
    }
    #wearDisplay {
        z-index: 100;
        position: absolute;
        user-select: none;
        width: 400px;
        height: 50px;
        border: 1px solid black;
        display: grid;
        grid-template-columns: repeat(400, 1fr);
    }
    #healthDisplay {
        z-index: 100;
        position: absolute;
        user-select: none;
        height: 20px;
    }
    #waveDisplay {
        z-index: 100;
        position: absolute;
        user-select: none;
        height: 20px;
    }
    #coinDisplay {
        z-index: 100;
        position: absolute;
        user-select: none;
        height: 20px;
    }
    #nextWaveBtn {
        position: absolute;
        z-index: 100;
        user-select: none;
        width: 100px;
        height: 50px;
        border: 1px solid black;
        /*center*/
        left: 50%;
        top: 50px;
        display: flex;
        justify-content: center;
        align-items: center;
        transform: translate(-50%, -50%);
    }
    #keybindHelp {
        position: absolute;
        z-index: 100;
        user-select: none;   
    }
    svg {
        z-index: 0;
    }

</style>
<head>
    <meta charset="UTF-8">
    <meta http-equiv="Content-Security-Policy" content="script-src 'self' 'unsafe-inline' 'unsafe-eval';">
    <script src="two.js"></script>
    <script src="math.js"></script>
</head>
<body>  
    <div class="debug" id="mouse"></div>
    <div id="healthDisplay">Health: 40</div>
    <div id="waveDisplay">Wave: 1</div>
    <div id="wearDisplay"></div>
    <div id="coinDisplay">Coins: 0</div>
    <div id="nextWaveBtn" onclick="clearShopGUI()">Next Wave</div>
    <div id="keybindHelp">h for keybind help</div>
</body>
<script>
    const mouseDebug = document.getElementById('mouse');
    const cannonWearDisplay = document.getElementById('wearDisplay');
    const playerHealthDisplay = document.getElementById('healthDisplay');
    const waveDisplay = document.getElementById('waveDisplay');
    const coinDisplay = document.getElementById('coinDisplay');
    const nextWaveBtn = document.getElementById('nextWaveBtn');
    const keybindHelp = document.getElementById('keybindHelp');

    function clearShopGUI(){
        nextWaveBtn.style.display = 'none';
        gameData.pauseWave = false;
    }

    function setShopGUI(){
        gameData.pauseWave = true;
        nextWaveBtn.style.display = 'flex';
           
    }

    for(i = 1; i <= 400; i++){
        let cell = document.createElement('div');
        cell.id = 'wearCell' + i;
        cell.style.backgroundColor = 'white';
        cell.style.height = '50px';
        cell.style.zIndex = '100';
        cannonWearDisplay.appendChild(cell);
    }

    let two = new Two({
        fullscreen: true,
        autostart: true
    }).appendTo(document.body);

    let debug = false;

    const gameData = {
        upKey: 'w',
        downKey: 's',
        leftKey: 'a',
        rightKey: 'd',
        shootKey1: 'e',
        shootKey2: 'q',
        toggleDebugKey: 'p',
        togglePauseKey: ' ',
        helpKey: 'h',
        intervalLength: 20, // 20
        borderOffset: debug ? 20 : 125, // 125
        borderWidth: 100, // 150
        frictionCoefficient: 0.9,
        keys: {
            q: false,
            e: false,
        },
        offsetDirectionDecider: Math.random() > 0.5 ? true : false,
        offsetDirection: 0.01,
        gradientRed: 0,
        gradientGreen: 255,
        gradientBlue: 0,
        regenAmnt: 0.4,
        currentEnemies: 0,
        currentWave: 0, // ===============
        regenAmnt: 0.125,
        playing: true,
        displayWave: 0, // ===============
        tick: 0,
        pauseWave: false,
    }
    
    const playerData = {
        vx: 0,
        vy: 0,
        x: Math.round(two.width / 2),
        y: Math.round(two.height / 2),
        width: 50,
        height: 50,
        speed: 1,
        borderCollision: false,
        mouseX: 0,
        mouseY: 0,
        cannonWear: 0,
        angle: null,
        cannonWearOffset: 0,
        maxWear: 400,
        bulletCount: 0,
        bulletData: {},
        shootAngle: null,
        regen: false,
        regenTimer: Date.now(),
        currentHealth: 40, // 40 ================
        maxHealth: 40, // 40 ============
        damage: 1, // =========
        bulletSpeed: 11, // ===============
        bulletDamage: 1, // ============
        bulletPiercing: 1, // ==========
        coins: 0,
    }
    const debugData = {
        vx: 0,
        vy: 0,
        x: 0,
        y: 0,
        borderCollision: false,
        mouseX: 0,
        mouseY: 0,
        cannonWear: 0, // ===========================================================================
        keys: {}
    }
    const enemyTypes = {
        'Grunt': {
            health: 1,
            speed: 1.5,
            damage: 1,
            name: 'Grunt',
            color: 'blue',
            size: 25,
            coins: 1,
        },
        'Footsoldier': {
            health: 1,
            speed: 2,
            damage: 1,
            name: 'Footsoldier',
            color: 'green',
            size: 25,
            coins: 1,
        },
        'Soldier': {
            health: 1,
            speed: 1.5,
            damage: 2,
            name: 'Soldier',
            color: 'gold',
            size: 30,
            coins: 1,
        },
        'Swarmer': {
            health: 1,
            speed: 2.25,
            damage: 0,
            name: 'Swarmer',
            color: 'darkorange',
            size: 15,
            coins: 0,
        },
        'Jumper': {
            health: 1,
            speed: 0,
            damage: 2,
            name: 'Jumper',
            color: 'turquoise',
            size: 30,
            coins: 2,
        },
        'Supersoldier': {
            health: 30,
            speed: 0.5,
            damage: 40,
            name: 'Supersoldier',
            color: 'firebrick',
            size: 80,
            coins: 10,
        }
    }

    clearShopGUI()


    const waveData = {
        1: function(){
            spawnEnemy('Grunt')
        },
        2: function(){
            spawnEnemy('Grunt')
            spawnEnemy('Grunt')
        },
        3: function(){
            spawnEnemy('Grunt')
            spawnEnemy('Grunt')
            spawnEnemy('Grunt')
        },
        4: function(){
            spawnEnemy('Grunt');
            spawnEnemy('Grunt');
            spawnEnemy('Grunt');
            spawnEnemy('Grunt');
        },
        5: function(){
            spawnEnemy('Grunt')
            spawnEnemy('Grunt')
            spawnEnemy('Grunt')
            spawnEnemy('Grunt')
            spawnEnemy('Grunt')
        },
        6: function(){
            spawnEnemy('Footsoldier')
            spawnEnemy('Grunt')
            spawnEnemy('Grunt')
            spawnEnemy('Grunt')
            spawnEnemy('Grunt')
        },
        7: function(){
            spawnEnemy('Footsoldier')
            spawnEnemy('Footsoldier')
            spawnEnemy('Grunt')
            spawnEnemy('Grunt')
            spawnEnemy('Grunt')
        },
        8: function(){
            spawnEnemy('Footsoldier')
            spawnEnemy('Footsoldier')
            spawnEnemy('Footsoldier')
            spawnEnemy('Grunt')
            spawnEnemy('Grunt')
        },
        9: function(){
            spawnEnemy('Footsoldier')
            spawnEnemy('Footsoldier')
            spawnEnemy('Footsoldier')
            spawnEnemy('Footsoldier')
            spawnEnemy('Grunt')
        },
        10: function(){
            spawnEnemy('Footsoldier')
            spawnEnemy('Footsoldier')
            spawnEnemy('Footsoldier')
            spawnEnemy('Footsoldier')
            spawnEnemy('Footsoldier')
        },
        11: function(){
            spawnEnemy('Soldier')
            spawnEnemy('Footsoldier')
            spawnEnemy('Grunt')
        },
        12: function(){
            spawnEnemy('Soldier')
            spawnEnemy('Soldier')
            spawnEnemy('Footsoldier')
            spawnEnemy('Grunt')
        },
        13: function(){
            spawnEnemy('Soldier')
            spawnEnemy('Soldier')
            spawnEnemy('Footsoldier')
            spawnEnemy('Footsoldier')
            spawnEnemy('Grunt')
        },
        14: function(){
            spawnEnemy('Soldier')
            spawnEnemy('Soldier')
            spawnEnemy('Soldier')
            spawnEnemy('Footsoldier')
            spawnEnemy('Footsoldier')
        },
        15: function(){
            spawnEnemy('Soldier')
            spawnEnemy('Soldier')
            spawnEnemy('Soldier')
            spawnEnemy('Soldier')
            spawnEnemy('Footsoldier')
        },
        16: function(){
            spawnEnemy('Grunt')
            spawnEnemy('Swarmer')
            spawnEnemy('Swarmer')
        },
        17: function(){
            spawnEnemy('Grunt')
            spawnEnemy('Swarmer')
            spawnEnemy('Swarmer')
            spawnEnemy('Swarmer')
        },
        18: function(){
            spawnEnemy('Grunt')
            spawnEnemy('Swarmer')
            spawnEnemy('Swarmer')
            spawnEnemy('Swarmer')
            spawnEnemy('Swarmer')
        },
        19: function(){
            spawnEnemy('Grunt')
            spawnEnemy('Grunt')
            spawnEnemy('Swarmer')
            spawnEnemy('Swarmer')
            spawnEnemy('Swarmer')
            spawnEnemy('Swarmer')
        },
        20: function(){
            spawnEnemy('Soldier')
            spawnEnemy('Footsoldier')
            spawnEnemy('Footsoldier')
            spawnEnemy('Swarmer')
            spawnEnemy('Swarmer')
            spawnEnemy('Swarmer')
            spawnEnemy('Swarmer')
        },
        21: function(){
            spawnEnemy('Soldier')
            spawnEnemy('Soldier')
            spawnEnemy('Jumper')
        },
        22: function(){
            spawnEnemy('Soldier')
            spawnEnemy('Jumper')
            spawnEnemy('Jumper')
        },
        23: function(){
            spawnEnemy('Soldier')
            spawnEnemy('Soldier')
            spawnEnemy('Jumper')
            spawnEnemy('Jumper')
        },
        24: function(){
            spawnEnemy('Soldier')
            spawnEnemy('Jumper')
            spawnEnemy('Jumper')
            spawnEnemy('Jumper')
            spawnEnemy('Jumper')
        },
        25: function(){
            spawnEnemy('Supersoldier')
        },
        26: function(){
            setShopGUI();
        }
    }

    function randomizer(values){
        let i, pickedValue, 
        randomNr = Math.random(),
        threshold = 0;
        for (i = 0; i < values.length; i++) {
            if (values[i].probability === '*'){ 
                continue;
            }
            threshold += values[i].probability; 
            if(threshold > randomNr) {
                pickedValue = values[i].value;
                break;
            }
            if (!pickedValue) {
                pickedValue = values.filter((value) => value.probability === '*');
            }
        }
        return pickedValue;
    }

    const enemyArray = ['Grunt', 'Footsoldier', 'Soldier', 'Swarmer', 'Jumper']
    const bossArray = ['Supersoldier']

    // create random waves
    function randomWave(){
        let wave = [];
        
        let spawnBoss = randomizer([
            {value: true, probability: 0.05},
            {value: false, probability: 0.95}
        ]);
        if(!spawnBoss){
            let waveLength = Math.floor(Math.random() * Math.floor(Math.random() * Math.ceil(gameData.currentWave  / 4)) + 1) + 1;
            let spawnProbabilities = []
            // create spawn probabilities
            for(let i = 0; i < enemyArray.length; i++){
                let probability = 0.5 / (i + 1)
                spawnProbabilities.push({value: enemyArray[i], probability: probability})
            }

            for (let i = 0; i < waveLength; i++) {
                let enemy = randomizer(spawnProbabilities);
                wave.push(`spawnEnemy("${enemy}");`);
            }

        } else {
            let waveLength = Math.floor(Math.random() * 3) + 1;
            let spawnProbabilities = []
            // create spawn probabilities
            for(let i = 0; i < bossArray.length; i++){
                let probability = 0.5 / (i + 1)
                spawnProbabilities.push({value: bossArray[i], probability: probability})
            }

            for (let i = 0; i < waveLength; i++) {
                let enemy = randomizer(spawnProbabilities);
                wave.push(`spawnEnemy("${enemy}");`);
            }
        }

        wave = wave.join("\n")
        const waveFunction = new Function(wave);
        waveData[Object.keys(waveData).length + 1] = waveFunction;
        return waveFunction;
    }
    

    
    let player = two.makeRectangle(two.width / 2, two.height / 2, 50 ,50);
    let playerCannonBase = two.makeRectangle(playerData.x, playerData.y, 30, 30);
    let playerCannon = two.makeRectangle(playerData.x + 25, playerData.y, 50, 20);

    function buildPlayer(){
        player.fill = 'red';
        player.stroke = 'red';
        player.id = 'player';

        playerCannon.fill = 'gradient';
        playerCannon.stroke = 'black';
        playerCannon.id = 'playerCannon';

        playerCannonBase.fill = 'black';
        playerCannonBase.stroke = 'black';
        playerCannonBase.id = 'player';

        playerData.angle = Math.atan2(playerData.mouseY - playerData.y, playerData.mouseX - playerData.x);
    }


    let borderLeft = two.makeRectangle(-gameData.borderOffset, 0, gameData.borderWidth, two.height * 2);
    let borderRight = two.makeRectangle(two.width + gameData.borderOffset, 0, gameData.borderWidth, two.height * 2);
    let borderTop = two.makeRectangle(0, -gameData.borderOffset, two.width * 2, gameData.borderWidth);
    let borderBottom = two.makeRectangle(0, two.height + gameData.borderOffset, two.width * 2, gameData.borderWidth);

    // make a border for the screen
    let screenLeft = two.makeRectangle(-gameData.borderOffset + 123, 0, 2, two.height * 2);
    let screenRight = two.makeRectangle(two.width + gameData.borderOffset - 123, 0, 2, two.height * 2);
    let screenTop = two.makeRectangle(0, -gameData.borderOffset + 123, two.width * 2, 2);
    let screenBottom = two.makeRectangle(0, two.height + gameData.borderOffset - 123, two.width * 2, 2);

    borderLeft.id = 'borderLeft'
    borderRight.id = 'borderRight'
    borderTop.id = 'borderTop'
    borderBottom.id = 'borderBottom'

    screenLeft.id = 'screenLeft'
    screenRight.id = 'screenRight'
    screenTop.id = 'screenTop'
    screenBottom.id = 'screenBottom'

    borderLeft.fill = 'blue'
    borderRight.fill = 'blue'
    borderTop.fill = 'blue'
    borderBottom.fill = 'blue'

    screenLeft.fill = 'black'
    screenRight.fill = 'black'
    screenTop.fill = 'black'
    screenBottom.fill = 'black'

    function constantUpdate(){
        setInterval(function(){
            if(!gameData.playing) return;
            gameData.tick++;
        }, 1)
        setInterval(function(){
            if(!gameData.playing) return;
            enemyController()
            waveController()
            if(Date.now() - playerData.regenTimer >= 5000){
                playerData.regen = true;
            }
            if(gameData.keys[gameData.shootKey1] == true || gameData.keys[gameData.shootKey2] == true){
                playerData.regen = false;
                playerData.regenTimer = Date.now();
            }

            if(playerData.regen){
                if(playerData.cannonWear > 0 && playerData.cannonWear < 400){
                    playerData.cannonWear = math.round(playerData.cannonWear - gameData.regenAmnt, 5);
                }
            }

            coinDisplay.innerHTML = "Coins: " + playerData.coins;

            for(i = 1; i <= 400; i++){
                let cell = document.getElementById('wearCell' + i);
                if(i <= playerData.cannonWear){
                    cell.style.backgroundColor = 'rgb(' + gameData.gradientRed + ',' + gameData.gradientGreen + ',' + gameData.gradientBlue + ')';
                } else {
                    cell.style.backgroundColor = 'white';
                }
            }

            if(playerData.cannonWear <= 400){
                let percentage = playerData.cannonWear / 400;
                if(playerData.cannonWear > 200){
                    gameData.gradientGreen = Math.round(510 - (510 * percentage));
                } else {
                    gameData.gradientRed = Math.round(510 * percentage);
                }
            }

            updateCannon();
            debugData.x = playerData.x;
            debugData.y = playerData.y;
            debugData.vx = playerData.vx;
            debugData.vy = playerData.vy;
            debugData.borderCollision = playerData.borderCollision;
            debugData.mouseX = playerData.mouseX;
            debugData.mouseY = playerData.mouseY;
            debugData.cannonWear = playerData.cannonWear;
            debugData.keys = gameData.keys;

            if(debug){
                mouseDebug.style.display = 'initial';
                gameData.borderOffset = 20;

            } else {
                mouseDebug.style.display = 'none';
                gameData.borderOffset = 125;
            }

            playerHealthDisplay.style.left = screenLeft.translation._x + screenLeft.width + 10 + 'px';
            playerHealthDisplay.style.top = screenTop.translation._y + screenTop.height + 70 + 'px';

            waveDisplay.style.left = screenLeft.translation._x + screenLeft.width + 10 + 'px';
            waveDisplay.style.top = screenTop.translation._y + screenTop.height + 90 + 'px';

            cannonWearDisplay.style.left = screenLeft.translation._x + screenLeft.width + 10 + 'px';
            cannonWearDisplay.style.top = screenTop.translation._y + screenTop.height + 10 + 'px';

            coinDisplay.style.left = screenLeft.translation._x + screenLeft.width + 10 + 'px';
            coinDisplay.style.top = screenTop.translation._y + screenTop.height + 110 + 'px';

            keybindHelp.style.left = screenLeft.translation._x + screenLeft.width + 10 + 'px';
            keybindHelp.style.top = screenTop.translation._y + screenTop.height + 130 + 'px';

            calculateBorders()

            let debugCannonWear = `Cannon Wear: ${debugData.cannonWear}\n`
            let debugPlayerX = `Player X: ${debugData.x}\n`
            let debugPlayerY = `Player Y: ${debugData.y}\n`
            let debugPlayerVX = `Player VX: ${debugData.vx}\n`
            let debugPlayerVY = `Player VY: ${debugData.vy}\n`
            let debugMouseX = `Mouse X: ${debugData.mouseX}\n`
            let debugMouseY = `Mouse Y: ${debugData.mouseY}\n`
            let debugBorderCollision = `Border Collision: ${debugData.borderCollision}\n`
            let debugKeys = `Keys: ${JSON.stringify(debugData.keys)}\n`

            mouseDebug.innerHTML = `<pre>${debugCannonWear}${debugPlayerX}${debugPlayerY}${debugPlayerVX}${debugPlayerVY}${debugMouseX}${debugMouseY}${debugBorderCollision}${debugKeys}</pre>`;

            if(playerData.cannonWear < 400){
                playerData.cannonWearOffset = 0.32
                if(playerData.cannonWear > 350){
                    playerData.cannonWearOffset = 0.29
                } else if(playerData.cannonWear > 300){
                    playerData.cannonWearOffset = 0.21
                } else if(playerData.cannonWear > 250){
                    playerData.cannonWearOffset = 0.15
                } else if(playerData.cannonWear > 200){
                    playerData.cannonWearOffset = 0.11
                } else if(playerData.cannonWear > 150){
                    playerData.cannonWearOffset = 0.05
                } else if(playerData.cannonWear > 100){
                    playerData.cannonWearOffset = 0.03
                } else if(playerData.cannonWear > 50){
                    playerData.cannonWearOffset = 0.01
                } else {
                    playerData.cannonWearOffset = 0
                }
            }

            if(playerData.vx <= 0.001 && playerData.vx >= -0.001){
                playerData.vx = 0;
            }

            if(playerData.vy <= 0.001 && playerData.vy >= -0.001){
                playerData.vy = 0;
            }

            playerData.x = math.round(playerData.x)
            playerData.y = math.round(playerData.y)
        }, gameData.intervalLength)
    }

    function updateCannon(){
        if(!gameData.playing) return;
        setTimeout(() => {
            if(playerData.cannonWear < 400){
                playerData.angle = Math.atan2(playerData.mouseY - playerData.y, playerData.mouseX - playerData.x) + playerData.cannonWearOffset;
            }
        }, playerData.cannonWear)

        playerCannon.rotation = playerData.angle;
        playerCannonBase.rotation = playerData.angle;

        playerCannon.translation.x = playerData.x + 25 * Math.cos(playerData.angle);
        playerCannon.translation.y = playerData.y + 25 * Math.sin(playerData.angle);

        playerCannonBase.translation.x = playerData.x;
        playerCannonBase.translation.y = playerData.y;


    }

    function waveController(){
        if(!gameData.playing) return;
        let enemies = two.scene.children.filter(child => child.type === 'enemy');
        if(enemies[0] == 0 && gameData.pauseWave == false){
            if(waveData[gameData.currentWave + 1] == undefined){
                randomWave();
                gameData.displayWave++; 
                gameData.currentWave++;
                waveData[gameData.currentWave]();
            } else {
                gameData.displayWave++;
                gameData.currentWave++;
                waveData[gameData.currentWave]();
                
            }
            waveDisplay.innerHTML = `Wave: ${gameData.displayWave}`;
        }
    }

    function spawnEnemy(enemyName){
        if(!gameData.playing) return;   
        // get a random x any y coordinate between the two borders
        let x = Math.random() * (borderRight.translation._x - borderLeft.translation._x) + borderLeft.translation._x;
        let y = Math.random() * (borderBottom.translation._y - borderTop.translation._y) + borderTop.translation._y;

        let enemy = two.makeRectangle(x, y, enemyTypes[enemyName].size, enemyTypes[enemyName].size);
        enemy.fill = enemyTypes[enemyName].color;
        enemy.stroke = enemyTypes[enemyName].color;
        enemy.type = 'enemy'
        enemy.name = enemyName;
        enemy.invincible = false,
        enemy.damage = enemyTypes[enemyName].damage;
        enemy.health = enemyTypes[enemyName].health;
        enemy.speed = enemyTypes[enemyName].speed;

        gameData.currentEnemies++;
    }

    function enemyController(){
        if(!gameData.playing) return;
        let enemies = two.scene.children.filter(child => child.type === 'enemy');
        if(enemies[0] != 0){
            
            


            enemies.forEach(enemy => {
                let health = enemy.health;
                let damage = enemy.damage;
                let speed = enemy.speed;

                let enemyColliding = checkCollision([player], [enemy])[0]
                if(enemyColliding){
                    removePlayerHealth(damage)
                    // remove the enemy
                    playerData.coins += enemyTypes[enemy.name].coins;
                    if(enemy.cannonElement != undefined){
                        enemy.cannonElement.remove();
                    }
                    if(enemy.name == 'supersoldier'){
                    }
                    enemy.remove();
                    gameData.currentEnemies--;
                }

                let angle = Math.atan2(playerData.y - enemy.translation._y, playerData.x - enemy.translation._x)

                if(enemy.name == 'Grunt'){
                    if(enemy.translation.x > playerData.x){
                        enemy.translation.x -= speed;
                    } else if(enemy.translation.x < playerData.x){
                        enemy.translation.x += speed;
                    }
                    
                    if(enemy.translation.y > playerData.y){
                        enemy.translation.y -= speed;
                    } else if(enemy.translation.y < playerData.y){
                        enemy.translation.y += speed;
                    }
                }
                if(enemy.name == 'Footsoldier'){
                    // move it towards the player
                    enemy.rotation = angle
                    enemy.translation.x += speed * Math.cos(angle);
                    enemy.translation.y += speed * Math.sin(angle);
                }
                if(enemy.name == 'Soldier'){
                    enemy.rotation = angle
                    // get distance between enemy and player
                    let distance = Math.sqrt(Math.pow(playerData.x - enemy.translation._x, 2) + Math.pow(playerData.y - enemy.translation._y, 2));
                    if(distance < 200){
                        speed = 2.5;
                    }
                    enemy.translation.x += speed * Math.cos(angle);
                    enemy.translation.y += speed * Math.sin(angle);
                }
                if(enemy.name == 'Swarmer'){
                    // get angle between enemy and mouse
                    let randomY = Math.random() * (50 - -50) + -50
                    let randomX = Math.random() * (50 - -50) + -50
                    let mouseAngle = Math.atan2((playerData.mouseY - enemy.translation._y) + randomY, (playerData.mouseX - enemy.translation._x) + randomX)

                    enemy.rotation = mouseAngle
                    enemy.translation.x += speed * Math.cos(mouseAngle);
                    enemy.translation.y += speed * Math.sin(mouseAngle);
                }
                if(enemy.name == 'Jumper'){
                    enemy.rotation = angle

                    // every second, change speed from 1 to 3, or 3 to 1
                    if(gameData.tick % 300 >= 280){
                        
                        if(speed == 0){
                            speed = 20;
                        } else {
                            speed = 0;
                
                        }
                    }

                    enemy.translation.x += speed * Math.cos(angle);
                    enemy.translation.y += speed * Math.sin(angle);
                }
                if(enemy.name == 'Supersoldier'){
                    if(enemy.spawnCannon == undefined){
                        enemy.spawnCannon = true;
                    }
                    
                    if(enemy.spawnCannon){
                        let enemyCannon = two.makeRectangle(enemy.translation._x + 50 * Math.cos(angle), enemy.translation._y + 50 * Math.sin(angle), 100, 25);


                        enemyCannon.name = 'Supersoldier';
                        enemyCannon.parentElement = 'Supersoldier'
                        enemyCannon.name2 = 'supersoldierCannon'
                        enemyCannon.rotation = angle
                        enemy.spawnCannon = false;
                    }

                    // set the rotation of the cannon
                    let enemyCannon = two.scene.children.filter(child => child.name2 === 'supersoldierCannon')[0]

                    two.scene.remove(enemy)
                    two.scene.remove(enemyCannon)

                    two.scene.add(enemy)
                    two.scene.add(enemyCannon)

                    enemyCannon.rotation = angle
                    enemyCannon.translation._x = enemy.translation._x + 50 * Math.cos(angle);
                    enemyCannon.translation._y = enemy.translation._y + 50 * Math.sin(angle);

                    enemyCannon.fill = 'black'

                    
                    if(enemy.attackCount == undefined){
                        enemy.attackCount = 0;
                    }



                    if(enemy.attacking == undefined){
                        enemy.attacking = true;
                    }

                    if(enemy.attackTime == undefined){
                        enemy.attackTime =  gameData.tick;
                    }

                    if(enemy.attackLock == undefined){
                        enemy.attackLock = false;
                    }
    
                    if(gameData.tick % 100 >= 95 && !enemy.attackLock && enemy.attacking){
                        enemy.attackLock = true;
                        let damagingRect = two.makeRectangle(enemy.translation._x + 60 * Math.cos(angle), enemy.translation._y + 60 * Math.sin(angle), 60, 15);

                        two.scene.remove(enemy)
                        two.scene.remove(damagingRect)

                        two.scene.add(damagingRect)
                        two.scene.add(enemy)

                        damagingRect.parentElement = 'Supersoldier'
                        damagingRect.fill = 'black';
                        damagingRect.type = 'supersoldierDamagingRect'
                        damagingRect.rotation = angle;
                        

                        damagingRect.damageLock = false;
                        damagingRect.spawnTick = gameData.tick;

                        enemy.attackCount++;
                        enemy.attackTime = gameData.tick;
                    } else {
                        enemy.attackLock = false;
                    }
                    

                    if(enemy.attackCount >= 5){
                        enemy.attackCount = 0;
                        enemy.attacking = false;
                    }

                    if(!enemy.attacking){
                        enemy.speed = 0.5;
                        if(gameData.tick - enemy.attackTime >= 800){
                            enemy.attacking = true;
                        }
                    } else {
                        enemy.speed = 0;
                    }


                    enemy.translation.x += speed * Math.cos(angle);
                    enemy.translation.y += speed * Math.sin(angle);
                }


                // see if there is a supersoldierDamagingRect
                let supersoldierDamagingRects = two.scene.children.filter(child => child.type === 'supersoldierDamagingRect');
                if(supersoldierDamagingRects[0] != 0){
                    supersoldierDamagingRects.forEach(supersoldierDamagingRect => {
                        // every tick, move it forward
                        let collisionRecord = [];
                        supersoldierDamagingRect.translation.x += 15 * Math.cos(supersoldierDamagingRect.rotation);
                        supersoldierDamagingRect.translation.y += 15 * Math.sin(supersoldierDamagingRect.rotation);


                        // if the supersoldierDamagingRect is fully outside of the screen, remove it
                        if(supersoldierDamagingRect.translation._x > two.width + 100 || supersoldierDamagingRect.translation._x < -100 || supersoldierDamagingRect.translation._y > two.height + 100 || supersoldierDamagingRect.translation._y < -100){
                            supersoldierDamagingRect.remove();
                        }

                        // if the supersoldierDamagingRect collides with the player, remove 3 from the player's health
                        let isColliding = checkCollision([player], [supersoldierDamagingRect])[0]
                        if(isColliding && supersoldierDamagingRect.damageLock == false){
                            supersoldierDamagingRect.damageLock = true;
                            removePlayerHealth(2)
                        }



                    })
                }



                let bullets = two.scene.children.filter(child => child.type === 'playerBullet');
                // if a bullet hits an enemy, subtract the health
                if(bullets[0] != 0){
                    bullets.forEach(bullet => {
                        // get the bullets 4 corners
                        let bulletTL = {x: bullet.translation._x - bullet.width / 2, y: bullet.translation._y - bullet.height / 2};
                        let bulletTR = {x: bullet.translation._x + bullet.width / 2, y: bullet.translation._y - bullet.height / 2};
                        let bulletBL = {x: bullet.translation._x - bullet.width / 2, y: bullet.translation._y + bullet.height / 2};
                        let bulletBR = {x: bullet.translation._x + bullet.width / 2, y: bullet.translation._y + bullet.height / 2};

                        // get the enemies 4 corners (account for rotation)
                        let enemyTL = {x: enemy.translation._x - enemy.width / 2, y: enemy.translation._y - enemy.height / 2};
                        let enemyTR = {x: enemy.translation._x + enemy.width / 2, y: enemy.translation._y - enemy.height / 2};
                        let enemyBL = {x: enemy.translation._x - enemy.width / 2, y: enemy.translation._y + enemy.height / 2};
                        let enemyBR = {x: enemy.translation._x + enemy.width / 2, y: enemy.translation._y + enemy.height / 2};

                        // expand the enemies corners to account for rotation

                        let expandAmnt = 6;
                        enemyTL.x -= expandAmnt
                        enemyTL.y -= expandAmnt

                        enemyTR.x += expandAmnt
                        enemyTR.y -= expandAmnt

                        enemyBL.x -= expandAmnt
                        enemyBL.y += expandAmnt

                        enemyBR.x += expandAmnt
                        enemyBR.y += expandAmnt

                        

                        // check if the bullets corners are inside the enemies corners
                        if(bulletTL.x > enemyTL.x && bulletTL.x < enemyTR.x && bulletTL.y > enemyTL.y && bulletTL.y < enemyBL.y){
                            enemy.health -= bullet.damage;
                            bullet.remove();
                        }
                        if(bulletTR.x > enemyTL.x && bulletTR.x < enemyTR.x && bulletTR.y > enemyTL.y && bulletTR.y < enemyBL.y){
                            enemy.health -= bullet.damage;
                            bullet.remove();
                        }
                        if(bulletBL.x > enemyTL.x && bulletBL.x < enemyTR.x && bulletBL.y > enemyTL.y && bulletBL.y < enemyBL.y){
                            enemy.health -= bullet.damage;
                            bullet.remove();
                        }
                        if(bulletBR.x > enemyTL.x && bulletBR.x < enemyTR.x && bulletBR.y > enemyTL.y && bulletBR.y < enemyBL.y){
                            enemy.health -= bullet.damage;
                            bullet.remove();
                        }


                    })
                }

                if(enemy.health <= 0){
                    
                    // if the enemy was a supersoldier, remove everything with a parentElement of 'Supersoldier'

                    let superSoldierElements = two.scene.children.filter(child => child.parentElement === 'Supersoldier');
                    if(superSoldierElements[0] != 0){
                        superSoldierElements.forEach(element => {
                            element.remove();
                        })
                    }
                    playerData.coins += enemyTypes[enemy.name].coins;
                    enemy.remove();
                    gameData.currentEnemies--;
                }
            })
        }
    }

    function calculateBorders(){
        if(!gameData.playing) return;
        // replace all of the borders and screens
        borderRight.translation.x = two.width + gameData.borderOffset;
        borderRight.height = two.height * 2;

        borderBottom.translation.y = two.height + gameData.borderOffset;
        borderBottom.width = two.width * 2;

        borderTop.translation.y = -gameData.borderOffset;
        borderTop.width = two.width * 2;

        borderLeft.translation.x = -gameData.borderOffset;
        borderLeft.height = two.height * 2;

        screenRight.translation.x = two.width + gameData.borderOffset - 123;
        screenRight.height = two.height * 2;

        screenBottom.translation.y = two.height + gameData.borderOffset - 123;
        screenBottom.width = two.width * 2;

        screenTop.translation.y = -gameData.borderOffset + 123;
        screenTop.width = two.width * 2;

        screenLeft.translation.x = -gameData.borderOffset + 123;
        screenLeft.height = two.height * 2;

        // get the width between the border and the screen
    }

    window.onresize = () => {
        if(!gameData.playing) return;
        calculateBorders()

        playerData.x = Math.round(two.width / 2);
        playerData.y = Math.round(two.height / 2);
    }

    function checkCollision(rects, colliders){
        if(!gameData.playing) return;
        let collision = false;
        let collider = undefined;
        let colliderElement = undefined;
        let rect = undefined;
        for(i = 0; i < rects.length; i++){
            if(collision) break;
            for(j = 0; j < colliders.length; j++){
                let rectMinX = rects[i].translation._x - rects[i].width / 2;
                let rectMaxX = rects[i].translation._x + rects[i].width / 2;
                let rectMinY = rects[i].translation._y - rects[i].height / 2;
                let rectMaxY = rects[i].translation._y + rects[i].height / 2;

                let colliderMinX = colliders[j].translation._x - colliders[j].width / 2;
                let colliderMaxX = colliders[j].translation._x + colliders[j].width / 2;
                let colliderMinY = colliders[j].translation._y - colliders[j].height / 2;
                let colliderMaxY = colliders[j].translation._y + colliders[j].height / 2;

                if(rectMinX < colliderMaxX && rectMaxX > colliderMinX && rectMinY < colliderMaxY && rectMaxY > colliderMinY){
                    collider = colliders[j].id;
                    collision = true;
                    colliderElement = document.getElementById(colliders[j].id)
                    rect = rects[i];
                    break;
                }
                // get the collider element


            }
            if(collision) break;
        }
        return [collision, collider, colliderElement, rect];
    }

    function spawnPlayerBullet(){
        if(!gameData.playing) return;
        let bullet = two.makeRectangle(playerCannon.translation.x, playerCannon.translation.y, 10, 10);
        bullet.rotation = playerData.angle;


        bullet.translation.x += 15 * Math.cos(playerData.angle);
        bullet.translation.y += 15 * Math.sin(playerData.angle);
        bullet.fill = 'red';
        bullet.stroke = 'black';
        bullet.linewidth = 1;
        bullet.id = 'playerBullet' + playerData.bulletCount;

        bullet.type = 'playerBullet';
        bullet.angle = playerData.angle;
        bullet.speed = playerData.bulletSpeed;
        bullet.health = playerData.bulletHealth;
        bullet.damage = playerData.bulletDamage;
        bullet.piercing = playerData.bulletPiercing;
        bullet.borderCollision = false;


        two.scene.remove(playerCannon);
        two.scene.remove(playerCannonBase);
        two.scene.add(bullet);
        two.scene.add(playerCannon);
        two.scene.add(playerCannonBase);

        playerData.bulletCount++;
    }

    function borderWrapController(elements, elementData){
        if(!gameData.playing) return;
        let isColliding = checkCollision(elements, [borderLeft, borderRight, borderTop, borderBottom])[0];
        let collider = checkCollision(elements, [borderLeft, borderRight, borderTop, borderBottom])[1];


        if(isColliding && !elementData.borderCollision){
            if(collider == 'borderLeft'){
                elementData.x = (two.width - borderLeft.translation._x) - (elementData.width / 2) - (gameData.borderWidth / 2);
                elementData.borderCollision = true;
            }
            if(collider == 'borderRight'){
                elementData.x = (elementData.width / 2) + (gameData.borderWidth / 2) + borderLeft.translation._x;
                elementData.borderCollision = true;
            }
            if(collider == 'borderTop'){
                elementData.y = (two.height - borderTop.translation._y) - (elementData.height / 2)  - (gameData.borderWidth / 2);
                elementData.borderCollision = true;
            }
            if(collider == 'borderBottom'){
                elementData.y = (elementData.height / 2) + (gameData.borderWidth / 2) + borderTop.translation._y;
                elementData.borderCollision = true;
            }
        }
    }

    function removePlayerHealth(amnt){
        if(!gameData.playing) return;
        // remove amnt from player health and update the health bar
        playerData.currentHealth -= amnt;
        playerHealthDisplay.innerHTML = "Health: " + playerData.currentHealth

        if(playerData.currentHealth <= 0){
            // reload window
            gameData.playing = false;
            alert('you died lol')
            window.location.reload();
        }
    }

    function movePlayer(x, y){
        if(!gameData.playing) return;
        playerData.x += x;
        playerData.y += y;

        player.translation._x += playerData.x;
        player.translation._y += playerData.y;

        player.translation.set(playerData.x, playerData.y);
    }

    playerData.angle = Math.atan2(playerData.mouseY - playerData.y, playerData.mouseX - playerData.x);

    function playerController(){
        if(!gameData.playing) return;
        function shoot(){
            let random = Math.floor(Math.random() * 200);
            if(random <= 60){
                if(playerData.cannonWear < 400){
                    if(gameData.keys[gameData.shootKey1]){
                        math.round(playerData.cannonWear = playerData.cannonWear + 20);
                    } else {
                        math.round(playerData.cannonWear = playerData.cannonWear + 2);
                    }
                    

                }
            }

            playerData.cannonWear = Math.round(playerData.cannonWear)
            playerData.bulletCount++;
            spawnPlayerBullet()
        }

        document.onmousedown = e => {
            gameData.keys[e.button] = true;
            if(e.button == 0){
                shoot();
            }
        }

        document.onmouseup = e => {
            gameData.keys[e.button] = false;
        }
        

        document.onkeydown = e => {
            let key = e.key.toLowerCase();
            gameData.keys[key] = true;
            if(gameData.keys[gameData.shootKey1]){
                if(playerData.cannonWear < 400){
                    shoot();
                }
            }
            if(gameData.keys[gameData.shootKey2] && e.repeat == false){
                shoot();
            }
            if(gameData.keys[gameData.toggleDebugKey]){
                debug = !debug;
            }
            if(gameData.keys[gameData.togglePauseKey]){
                gameData.playing = !gameData.playing;
            }
            if(gameData.keys[gameData.helpKey]){
                confirm('wasd to move\nq or left click to shoot\ne to rapid fire\nspace to pause')
                gameData.keys[gameData.helpKey] = false;
            }
        };

        document.onkeyup = e => {
            let key = e.key.toLowerCase();
            gameData.keys[key.toLowerCase()] = false;
        }

        document.onmousemove = e => {
            mouseDebug.style.left = e.clientX + 10 + 'px';
            mouseDebug.style.top = e.clientY + 'px';

            setTimeout(() => {
                playerData.mouseX = e.clientX
                playerData.mouseY = e.clientY
            }, playerData.cannonWear)
        }

        function move(){
            if(!gameData.playing) return;
            borderWrapController([player], playerData)
            if(gameData.keys[gameData.upKey]){
                playerData.vy -= playerData.speed;
                playerData.borderCollision = false;
            }
            if(gameData.keys[gameData.downKey]){
                playerData.vy += playerData.speed;
                playerData.borderCollision = false;
            }
            if(gameData.keys[gameData.leftKey]){
                playerData.vx -= playerData.speed;
                playerData.borderCollision = false;
            }
            if(gameData.keys[gameData.rightKey]){
                playerData.vx += playerData.speed;   
                playerData.borderCollision = false;  
            }

            playerData.vx = math.round(playerData.vx * gameData.frictionCoefficient, 4);
            playerData.vy = math.round(playerData.vy * gameData.frictionCoefficient, 4);

            movePlayer(playerData.vx, playerData.vy);
        }

        setInterval(move, gameData.intervalLength);
    }

    function bulletController(){
        if(!gameData.playing) return;
        function move(){
            if(!gameData.playing) return;
            let bullets = two.scene.children.filter(child => child.type == 'playerBullet');
            if(bullets[0] != 0){
                for(let i = 0; i < bullets.length; i++){

                    let bullet = bullets[i];
                    let angle = bullet.angle;
                    let speed = bullet.speed;

                    // move the bullet in the direction the cannon is facing
                    let x = bullet.translation._x + (speed * Math.cos(angle));
                    let y = bullet.translation._y + (speed * Math.sin(angle));
                    
                    bullet.translation.set(x, y);

                    if(bullet.translation._x > two.width || bullet.translation._x < 0 || bullet.translation._y > two.height || bullet.translation._y < 0){
                        two.remove(bullet);
                    }
                }
            }

        }

        setInterval(move, gameData.intervalLength);
    }

    document.oncontextmenu = e => {
        e.preventDefault();
    }

    buildPlayer();
    playerController();
    constantUpdate();
    bulletController();


    // npm start
    // electron-packager ./ JS-Game --platform=win32 --arch=ia32 ./JS-Game
</script>